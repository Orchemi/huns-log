---
title: "[Python] 변수"

categories:
  - Python SWEA

tags:
  - [BE Language, Python Lang, Python SWEA]

author_profile: true

date: 2021-12-31T00:55
last-modified-at: 2021-12-31T00:55

toc: true
toc_label: "목차"
toc_icon: "bars"
toc_sticky: true
published: false
---

## 참고 강의

`[SWEA 파이썬 프로그래밍 기초(1) 파이썬의 기본 구조와 기초 문법 #4](https://swexpertacademy.com)`

<br />

## 변수

어떠한 값을 저장하는 그릇(식별자)

### 변수 자료형 식별 : type()

```python

>>> num = 10
>>> str = "홍길동"
>>> lst = [1, 2, 3]

>>> print(type(num))
<class 'int'> # 정수형 변수

>>> print(type(str))
<class 'str'> # 문자열 변수

>>> print(type(lst))
<class 'lst'> # 리스트 변수
```

- 파이썬의 동적 타이핑 언어 특징, 저장된 값의 자료형에 의해 변수 자료형 결정
- 변경이 가능한 변수에 의도치 않은 값이 전달되면, 변수의 자료형이 변경될 수 있어 주의
- TypeError와 같은 오류 발생 가능 -> **변수는 하나의 자료형만을 사용할 것을 권장**

### 변수명

- 숫자로 시작하는 변수는 만들 수 없다.
- 문자의 대소문자는 꼭 구분한다.
- 파이썬3부터는 한글로 된 변수명을 만들 수 있다.
- 파이썬의 예약어는 사용할 수 없다. (ex. False, None, True, and, assert, break ...)

### 변수와 객체

변수는 객체에 대한 식별자 역할을 수행한다.

```python
>>> var1 = 10
# Step 1. 메모리 공간에 정수 10의 값을 가진 객체 생성
# Step 2. Step 1. 에서 생성된 객체를 var1이 참조

>>> var2 = 10
# Step 3. Step 2. 에서 생성된 객체를 var2이 참조

>>> print(var1 is var2)
True
# Step 4. 두 변수가 동일 객체 참조

>>> var3 = 20
# Step 5. 메모리 공간에 정수 20의 값을 가진 객체 생성
# Step 6. Step 5. 에서 생성된 객체를 var3이 참조

>>> print(var1 is var3)
False
# Step 7. 두 객체가 서로 다른 변수를 참조하고 있음을 확인
```

<br />

## 자료형

### Bool형

- 참 거짓을 판단하는 표현식에 사용하는 자료형
- 관계 연산자, 논리 연산자를 사용하는 표현식이 Bool 값 반환

#### Bool 값을 반환하는 관계 연산

```python
>>> x, y = 10, 20

>>> print(x)
10

>>> print(y)
20

>>> print(x < y) # x(10) < y(20)
True
```

#### Bool 값을 반환하는 논리 연산

```python
>>> under18 = False
>>> male = True

>>> print(under18 and male)
False
# False와 True에 대한 논리 연산자 and의 연산 결과 : False
```

#### 조건문에 사용되는 Bool 값

```python
>>> under18 = False
>>> male = True

>>> if under 18:
      print("미성년자입니다.")
    else:
      print("성인입니다.")

성인입니다.
```

<br />

### Tuple

- () 안에 서로 다른 자료형의 값을 콤마(,)로 구분해 하나 이상 저장할 수 있는 컬렉션 자료형
- 0부터 시작하는 인덱스를 이용해 접근 가능
- **한 번 저장된 항목은 변경할 수 없음**

```python
>>> student = ("홍길동", 20)
>>> student = "홍길동", 20  # 위의 코드와 동일

>>> print(student)
('홍길동', 20)

# index 활용
>>> print(student[0])
'홍길동'

>>> print(student[1])
20


# Error 확인
>>> print(student[2])
Traceback...
IndexError: tuple index out of range
# student tuple은 2개의 원소를 가지므로
# 유효하지 않은 인덱스 범위를 넣으면 IndexError 발생


```

#### IndexError

student tuple은 2개의 원소를 가지므로 유효하지 않은 인덱스 범위를 넣으면 IndexError 발생

```python
>>> student = ("홍길동", 20)

>>> print(student[2])

Traceback...
IndexError: tuple index out of range
```

#### TypeError

tuple은 한 번 저장된 항목의 값을 변경할 수 없기 때문에 이미 유효한 인덱스에 새 데이터를 넣으려 하면 TypeError 발생

```python
>>> student = ('홍길동', 20)

>>> student[1] = 21

Traceback...
TypeError: 'tuple' object does not support item assignment


>>> student = ('임꺽정', 30)
>>> print(student)
('임꺽정', 30)

# student는 변수이므로 새로운 tuple 객체를 참조하는 것은 문제가 되지 않음.
```

<br />

### List

- [] 안에 서로 다른 자료형의 값을 콤마(,)로 구분해 하나 이상 저장할 수 있는 컬렉션 자료형
- 0부터 시작하는 인덱스를 이용해 접근
- **한 번 저장된 항목이라도 변경할 수 있음**

```python
>>> student = ["홍길동", 20]
>>> print(student)
['홍길동', 20]

>>> print(student[0])
'홍길동'
# index를 이용해 개별 항목에 접근 가능


>>> print(student[2])
IndexError 발생


>>> student[1] = 21
>>> print(student)
['홍길동', 21]  # tuple과 달리 list는 항목을 수정할 수 있음.


>>> student = ["임꺽정", 30]
>>> print(student)
['임꺽정', 30]  # student 변수가 새로운 list 객체 참조 가능
```

<br />

### Set

- {} 안에 서로 다른 자료형의 값을 콤마(,)로 구분해 하나 이상 저장할 수 있는 컬렉션 자료형
- 순서의 개념이 존재하지 않아 **인덱스를 사용할 수 없음**
- **데이터 항목의 중복 허용 X**

```python
>>> student = {"홍길동", "이순신", "강감찬", "홍길동"}

>>> print(student)
{"홍길동", "이순신", "강감찬"}  # 중복된 홍길동 제거

>>> print(len(student))
3 # student set 내의 항목의 개수


>>> student[0]
Traceback...
TypeError: 'set' object does not support indexing
# set은 index를 사용할 수 없다는 TypeError 발생
```

- 항목 추가

```python
>>> student = {"홍길동", "이순신", "강감찬", "홍길동"}
>>> student |= {"을지문덕", "이순신"}
# 집합의 개념을 가지고 있는 자료구조
# 합집합 연산자 제공

>>> print(student)
{'을지문덕', '홍길동', '이순신', '강감찬'}

```

- 새로운 set 정의

```python
>>> student = {'을지문덕', '홍길동', '이순신', '강감찬'}
>>> student = {"임꺽정", 30}  # student 변수 재정의

>>> student
{'임꺽정', 30}
```

<br />

### Dictionary

- {} 안에 키:값 형식의 항목을 콤마(,)로 구분해 하나 이상 저장할 수 있는 컬렉션 자료형 {키:값}
- 키를 이용해 값을 읽어올 수 있음
- 항목을 추가할 때
  - 동일키가 없으면 : 새로운 항목 추가
  - 동일키가 있으면 : 저장된 항목 변경
- 키는 일반적으로 문자열이나 정수형을 사용

```python
>>> dogs = {1: "골든리트리버", 2: "진돗개", 3:"보더콜리"}

>>> dogs
{1: '골든리트리버', 2: '진돗개', 3:'보더콜리'}


# 키를 이용하여 값 출력
>>> dogs[1]
골든리트리버

>>> dogs[2]
진돗개


# KeyError
>>> dogs[4]
Traceback...
KeyError: 4 # 존재하지 않는 Key 4에 의해 문제 발생
```

- 특정 Key의 값 변경

```python
>>> dogs = {1: "골든리트리버", 2: "진돗개", 3:"보더콜리"}
>>> dogs[2] = "레브라도리트리버"

>>> dogs
{1: '골든리트리버', 2: '레브라도리트리버', 3:'보더콜리'}
```

- 새로운 Key와 Value 추가

```python
>>> dogs = {1: "골든리트리버", 2: "진돗개", 3:"보더콜리"}
>>> dogs["4"] = "알레스카말라뮤트"

>>> dogs
{1: '골든리트리버', 2: '레브라도리트리버', 3:'보더콜리', '4': '알레스카말라뮤트'}

# 새로운 "4"번 Key에 '알레스카말라뮤트' 값 추가
# 정수 4와 문자열 "4"는 자료형이 다르다.

>>> dogs[4]
Traceback...
KeyError: 4  # 숫자형 4 Key가 없어 KeyError 발생

>>> dogs["4"]
알레스카말라뮤트
```

<br />

### None 객체

- Null 상태를 표현하는 객체
- Null : 객체가 존재하지 않는 상태

<u>주의🙄</u> Python에서는 최초 변수를 선언할 때 초기화하지 않으면 에러 발생
 

> 초기화 값을 저장하지 않을 때에는 None 객체를 저장하자

```python
>>> obj
Traceback...
NameError: name 'obj' is not defined
# 메모리 공간에서 obj라는 변수를 찾지 못해 발생하는 Error

# obj에 어떠한 값도 저장하고 싶지 않을 경우 None 객체 저장
>>> obj = None

>>> print(obj is None)  # 어떤 것에 여부를 검사(권장)
True

>>> print(obj == None)  # 좌우변이 동일한 값인지를 검사
True
```

- if문인 경우 : False로 평가된다.

```python
>>> obj = None

>>> if obj:
      print("obj는 None이 아닙니다.")
    else:
      print("obj는 None입니다.")

obj는 None입니다.
```

<br />

## 변수의 생성 및 제거

- 변수는 기본적으로 한 번에 하나씩 생성
- 그 이상의 변수를 한꺼번에 생성하기도 함

```python
>>> x = y = 10

>>> print(x)
10

>>> print(y)
10

>>> x, y = (10, 20)
>>> print(x, y)
10 20

>>> print((x, y))
(10, 20)


>>> x, y = 10, 20
>>> print(x, y)
10 20

>>> print((x, y))
(10, 20)
```

- 변수의 값끼리 쉽게 교체 가능

```python
>>> x, y = 10, 20
>>> x, y = y, x  # 두 변수끼리 값 교체

>>> x
20

>>> y
10
```

<br />

### 변수의 제거

- GC(Garbage Collector)에 의해 객체가 사용한 메모리 공간 자동관리
- 개발자가 메모리 관리를 직접할 필요가 없다.
- **사용하지 않는 변수를 직접 제거할 경우 del() 함수 사용**

```python
>>> x = 10
>>> y = 20

>>> del(x)
>>> del(y)

>>> print(x)
Traceback...
NameError: name 'x' is not defined
# 변수 x가 제거되어 NameError 발생
```
