---
title: "[SQL] SQL의 CRUD"

categories:
  - SQL

tags:
  - [DB, SQL]

date: 2022-03-14T14:00
last_modified_at: 2022-03-14T14:00

author_profile: true

toc: true
toc_label: "목차"
toc_icon: "bars"
toc_sticky: true
published: false
---

## SQL문 CRUD

- 대문자로 작성
- 테이블이나 컬럼 이름과 구분 가능

<br />

## CREATE : 테이블 생성 및 확인

> 문법

```sql
CREATE TABLE [table_name] (col1 val1, col2 val2,..);
```

<br />

> 예시

```sql
-- classmate 테이블과 함께 data type과 column을 정의
CREATE TABLE classmate (
  id INTEGER PRIMARY KEY,
  name TEXT
);
```

<br />

## INSERT : 테이블에 데이터 삽입

> 문법 1 : 컬럼 명시

```sql
INSERT INTO [table_name] (col1, col2,...) VALUES (val1, val2, ...);
```

<br />

> 문법 2 : 컬럼 명시 X

모든 열에 대한 데이터를 순서대로 넣을 때에는 컬럼 생략 가능

```sql
INSERT INTO [table_name] VALUES (val1, val2, ...);
```

<br />

### rowid

> Q. id는 어디 있을까?

- SQLite는 PK 속성 컬럼을 따로 작성하지 않으면, `자동 증가 PK 옵션의 rowid 컬럼`을 정의
- 아래처럼 출력에서 확인할 수 있다.

```sql
SELECT rowid, * FROM classmates;
```

<br />

### NOT NULL

> Q. 정의된 어떤 컬럼에 대해 값이 없는 레코드, 이대로 괜찮은가?

- 스키마를 지정할 때 NOT NULL 속성값을 함께 지정
- 반드시 들어가야 하는 필드를 특정한다.

```sql
CREATE TABLE classmate (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL,
  age INT NOT NULL,
  addresss TEXT NOT NULL
);
```

**⭐ `PRIMARY KEY` 속성값을 넣는 field의 data type은 반드시 `INTEGER` 여야 한다!!**

<br />

- 스키마에 id를 직접 작성하도록 하였다.
- 이 테이블 정의 이후 id 없이 INSERT한다면 아래와 같은 오류 발생

```
Parse error near line 4: table classmate has 4 columns but 3 values were supplied
```

<br />

### id 지정?

> id를 직접 넣는다.

```
INSERT INTO classmate VALUES (1, '홍길순', 20, '서울');
```

<br />

> column을 선택하고 그에 맞는 value를 매칭해서 넣는다.

```
INSERT INTO classmate (name, age, address) VALUES ('홍길동', 30, '서울');
```

<br />

### 다중 데이터 입력

- values 뒤의 tuple에 comma로 이어붙이면 된다.
- 맨 마지막 tuple 뒤에는 semicolon(;) 붙인다.

```sql
INSERT INTO classmates
VALUES
('홍길동', 30, '서울'),
('김철수', 30, '대전'),
('이벡터', 26, '대구'),
('박청년', 29, '전주'),
('최정보', 30, '부산');
```

<br />

## READ : SELECT

- 테이블에서 데이터 조회
- 다양한 절(clause)와 함께 사용
- ORDER BY, DISTINCT, WHERE, LIMIT, GROUP BY...

<br />

### 기본 문법

> 전체 컬럼 조회

```sql
SELECT * FROM [table_name];
```

<br />

> 특정 컬럼 조회

```sql
SELECT col1, col2, ... FROM [table_name];
```

<br />

### 절(Clause)

#### LIMIT

쿼리에서 반환되는 행 수 제한

<br />

> 문법

```sql
SELECT col1, col2, ... FROM [table_name] LIMIT [num];
```

<br />

> 예시

```sql
SELECT rowid, name FROM classmates LIMIT 1;
```

<br />

#### LIMIT OFFSET

- 특정 행부터 조회 시작
- OFFSET : 동일 오브젝트 안에서의 변위차
- `0부터 시작`한다고 생각하기

```sql
SELECT rowid, name FROM classmates LIMIT 1 OFFSET 2;
```

class 테이블의 3번째 레코드부터 1개를 SELECT

<br />

#### WEHRE

- 쿼리에서 반환된 행에 대한 특정 검색 조건 지정
- filter의 역할

```sql
SELECT rowid, name FROM classmates WHERE address = '서울';
```

<br />

#### SELECT DISTINCT

- 조회 결과에서 중복 행 제거
- SELECT 바로 뒤에 위치!!

```sql
SELECT DISTINCT age FROM classmates;
```

age가 중복되는 상황에서 중복을 제거하고 age만 SELECT

<br />

## DELETE

```sql
DELETE FROM [table_name] WHERE [조건]
```

- DELETE는 테이블을 삭제하는 것이 아니라 레코드를 삭제하는 것
- 중복 불가능한(UNIQUE) 값인 rowid 위주로 삭제하는 것이 좋다.

<br />

```sql
DELETE FROM classmates WHERE rowid=5;
```

- 이 이후에 레코드를 추가하면 id를 5번부터 누적
- 즉, id를 재사용한다는 것!

<br />

### ID의 재사용?

> Django는 id 재사용 안 하는데요?

- 기본적으로 SQLite는 id 재사용
- django는 `AUTOINCREMENT` 속성을 사용해 id 재사용을 피함!

<br />

### AUTOINCREMENT

- SQLite가 사용되지 않은 값이나 이전에 삭제된 행의 값을 재사용하는 것을 방지
- 테이블 정의시 초기에 지정

```sql
CREATE TABLE [table_name] (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  ...
);
```

<br />

## DROP : 테이블 삭제

```sql
DROP TABLE [table_name];
```

<br />

## UPDATE

- 기존 행의 데이터 수정
- SET 절에서 테이블의 각 열에 대해 새로운 값 설정

```sql
UPDATE [table_name] SET col1=val1, col2=val2, ... WHERE [조건]
```

- SET 이후 수정할 컬럼과 값을 지정
- 어떤 record를 수정할지 조건절(WHERE)이 추가될 수 있다.

<br />

> 예시

```sql
UPDATE classmates
SET name='홍길동', address='제주도'
WHERE rowid=5;
```

id가 5인 record의 이름과 주소를 수정